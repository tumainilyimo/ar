<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Navigation</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; }

        .camera-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 1;
        }

        .map-view {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            z-index: 2;
        }

        #map { width: 100%; height: 100%; }

        .controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            display: flex;
            gap: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
        }

        input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 140px;
        }

        button {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .direction-indicator {
            position: fixed;
            bottom: 42%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 3;
        }

        .ar-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 40px solid blue; /* Customize arrow color */
            z-index: 4;
        }
    </style>
</head>
<body>
    <div class="camera-view">
        <a-scene embedded vr-mode-ui="enabled: false" arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3_HAMMING63">
            <a-camera gps-camera rotation-reader look-controls-enabled="false"></a-camera>
            <a-entity id="ar-arrow-container">
                <a-entity id="ar-arrow" rotation="0 0 0">
                    <a-entity gltf-model="#arrowModel" scale="0.5 0.5 0.5" rotation="-90 0 0" color="blue"></a-entity>
                </a-entity>
            </a-entity>
            <a-assets>
                <a-asset-item id="arrowModel" src="https://cdn.aframe.io/examples/assets/models/arrow.gltf"></a-asset-item>
            </a-assets>
        </a-scene>
    </div>

    <div class="map-view">
        <div id="map"></div>
    </div>

    <div class="controls">
        <input type="text" id="start" placeholder="Start location">
        <input type="text" id="end" placeholder="End location">
        <button onclick="calculateRoute()">Route</button>
    </div>

    <div id="direction-panel" class="direction-indicator"></div>

    <script>
        let map, userMarker, routingControl;
        let routePoints = [];
        let userLocation = null;

        window.addEventListener('load', async () => {
            try {
                const position = await getPosition();
                userLocation = [position.coords.latitude, position.coords.longitude];
            } catch (err) {
                console.error('Geolocation error:', err);
                alert('Unable to get your location. Please enable GPS.');
                userLocation = [0, 0];
            }

            initMap();
        });

        function getPosition() {
            return new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 30000,
                    maximumAge: 0
                });
            });
        }

        function initMap() {
            map = L.map('map').setView(userLocation, 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            userMarker = L.marker(userLocation).addTo(map);

            navigator.geolocation.watchPosition(
                (pos) => {
                    userLocation = [pos.coords.latitude, pos.coords.longitude];
                    userMarker.setLatLng(userLocation);
                    updateNavigation();
                },
                console.error,
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 30000
                }
            );
        }

        async function calculateRoute() {
            const start = document.getElementById('start').value;
            const end = document.getElementById('end').value;

            if (!start || !end) {
                alert('Enter both locations');
                return;
            }

            try {
                const startCoords = await geocode(start);
                const endCoords = await geocode(end);

                if (!startCoords || !endCoords) {
                    alert('Location not found');
                    return;
                }

                if (routingControl) {
                    map.removeControl(routingControl);
                }

                routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(startCoords[0], startCoords[1]),
                        L.latLng(endCoords[0], endCoords[1])
                    ],
                    createMarker: () => null,
                    addWaypoints: false
                }).addTo(map);

                routingControl.on('routesfound', event => {
                    routePoints = event.routes[0].coordinates;
                    map.fitBounds(L.latLngBounds(routePoints), {padding: [50, 50]});
                    updateNavigation(); // Call updateNavigation after route is found
                });
            } catch (error) {
                console.error('Route error:', error);
                alert('Route calculation failed');
            }
        }

        async function geocode(location) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}`
                );
                const data = await response.json();
                return data.length ? [parseFloat(data[0].lat), parseFloat(data[0].lon)] : null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }

        function updateNavigation() {
            if (!routePoints.length || !userLocation) return;

            const nextPoint = findNextPoint();
            if (!nextPoint) return;

            const bearing = calculateBearing(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );

            const distance = calculateDistance(userLocation, [nextPoint.lat, nextPoint.lng]);

            document.getElementById('direction-panel').textContent =
                `${Math.round(bearing)}° - ${Math.round(distance)}m`;

            updateARArrow(nextPoint.lat, nextPoint.lng);
        }

        function updateARArrow(nextLatitude, nextLongitude) {
            const arrowContainer = document.getElementById('ar-arrow-container');
            arrowContainer.setAttribute('gps-entity-place', `latitude: ${nextLatitude}; longitude: ${nextLongitude}`);

            const userDirection = calculateDeviceBearing(); // Get device's heading
            if (userDirection !== null) {
                // Calculate the bearing from the user's location to the next point
                const bearingToNextPoint = calculateBearing(userLocation[0], userLocation[1], nextLatitude, nextLongitude);

                // Calculate the difference between the bearing to the next point and the device's heading
                let arrowRotation = bearingToNextPoint - userDirection;

                // Normalize the rotation to be within 0-360 degrees
                if (arrowRotation < 0) {
                    arrowRotation += 360;
                }

                const arArrow = document.getElementById('ar-arrow');
                arArrow.setAttribute('rotation', `0 ${arrowRotation} 0`);
            }
        }

        function calculateDeviceBearing() {
            // This function needs to handle device orientation events to get the compass heading.
            // It's platform-dependent and might require specific browser API handling.
            // For simplicity, we'll leave a basic implementation here that might need adjustments.
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', function(event) {
                    let compassHeading = event.webkitCompassHeading || Math.abs(event.alpha - 360);
                    // You might need to adjust the offset and accuracy based on your device.
                    return compassHeading;
                });
            } else {
                console.warn('Device orientation not supported');
                return null;
            }
            return null; // Return null if device orientation is not available immediately.
        }

        function findNextPoint() {
            if (routePoints.length === 0) return null;
            return routePoints[0]; // Always target the first point in the route
        }

        function calculateDistance(point1, point2) {
            const R = 6371e3;
            const φ1 = point1[0] * Math.PI/180;
            const φ2 = point2[0] * Math.PI/180;
            const Δφ = (point2[0]-point1[0]) * Math.PI/180;
            const Δλ = (point2[1]-point1[1]) * Math.PI/180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                     Math.cos(φ1) * Math.cos(φ2) *
                     Math.sin(Δλ/2) * Math.sin(Δλ/2);

            return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function calculateBearing(lat1, lon1, lat2, lon2) {
            const φ1 = lat1 * Math.PI/180;
            const φ2 = lat2 * Math.PI/180;
            const Δλ = (lon2-lon1) * Math.PI/180;

            const y = Math.sin(Δλ) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) -
                     Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

            return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
        }
    </script>
</body>
</html>
