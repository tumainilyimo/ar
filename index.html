<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AR Navigation</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
  <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <style>
    body { margin: 0; padding: 0; font-family: sans-serif; overflow: hidden; }
    .ar-view {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 60vh;
      z-index: 2;
    }
    .map-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 40vh;
      z-index: 1;
    }
    #map { width: 100%; height: 100%; }
    .controls {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      display: flex;
      gap: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .location-input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      width: 150px;
    }
    .route-btn {
      padding: 8px 16px;
      background: #4285f4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .direction-indicator {
      position: fixed;
      bottom: 45vh;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      z-index: 9999;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="ar-view">
    <a-scene embedded vr-mode-ui="enabled: false" arjs="sourceType: webcam; debugUIEnabled: false;">
      <a-camera gps-camera rotation-reader></a-camera>
      <a-entity id="routeMarkersContainer"></a-entity>
    </a-scene>
  </div>

  <div class="map-container">
    <div id="map"></div>
  </div>

  <div class="controls">
    <input type="text" id="startLocation" class="location-input" placeholder="Start location"/>
    <input type="text" id="endLocation" class="location-input" placeholder="End location"/>
    <button class="route-btn" id="routeBtn">Navigate</button>
  </div>

  <script>
    let map, userLocationMarker, routeControl;
    let routeCoords = [];

    async function init() {
      try {
        const position = await getCurrentPosition();
        initMap([position.coords.latitude, position.coords.longitude]);
        document.getElementById('routeBtn').addEventListener('click', handleRoute);
      } catch (err) {
        console.error('Initialization error:', err);
        alert('Please enable GPS location');
      }
    }

    function getCurrentPosition() {
      return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0
        });
      });
    }

    function initMap(center) {
      map = L.map('map').setView(center, 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
      userLocationMarker = L.marker(center).addTo(map);

      navigator.geolocation.watchPosition(
        pos => {
          const newPos = [pos.coords.latitude, pos.coords.longitude];
          userLocationMarker.setLatLng(newPos);
          updateARNavigation(newPos);
        },
        err => console.error('Location watch error:', err),
        { enableHighAccuracy: true }
      );
    }

    async function handleRoute() {
      const start = document.getElementById('startLocation').value.trim();
      const end = document.getElementById('endLocation').value.trim();
      
      if (!start || !end) {
        alert('Please enter both start and end locations');
        return;
      }

      try {
        const startCoords = await geocode(start);
        const endCoords = await geocode(end);
        
        if (!startCoords || !endCoords) {
          alert('Could not find one or both locations');
          return;
        }

        await createRoute(startCoords, endCoords);
      } catch (err) {
        console.error('Routing error:', err);
        alert('Error creating route');
      }
    }

    async function geocode(location) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}`;
      try {
        const response = await fetch(url);
        const data = await response.json();
        if (data && data.length > 0) {
          return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
        }
      } catch (err) {
        console.error('Geocoding error:', err);
      }
      return null;
    }

    function createRoute(start, end) {
      if (routeControl) {
        map.removeControl(routeControl);
      }

      routeControl = L.Routing.control({
        waypoints: [
          L.latLng(start[0], start[1]),
          L.latLng(end[0], end[1])
        ],
        routeWhileDragging: false,
        addWaypoints: false,
        createMarker: () => null
      }).addTo(map);

      return new Promise((resolve) => {
        routeControl.on('routesfound', (e) => {
          const route = e.routes[0];
          routeCoords = route.coordinates;
          
          const bounds = L.latLngBounds(route.coordinates);
          map.fitBounds(bounds, { padding: [50, 50] });
          
          createARMarkers();
          resolve();
        });
      });
    }

    function createARMarkers() {
      const container = document.getElementById('routeMarkersContainer');
      container.innerHTML = '';

      routeCoords.forEach((coord, i) => {
        if (i % 5 !== 0) return; // Place marker every 5th coordinate to avoid overcrowding

        const entity = document.createElement('a-entity');
        entity.setAttribute('gps-entity-place', `latitude: ${coord.lat}; longitude: ${coord.lng}`);
        
        const arrow = document.createElement('a-cone');
        arrow.setAttribute('color', '#4285f4');
        arrow.setAttribute('height', '3');
        arrow.setAttribute('radius-bottom', '0.5');
        arrow.setAttribute('position', '0 3 0');
        
        const text = document.createElement('a-text');
        text.setAttribute('value', `${(i + 1)}`);
        text.setAttribute('align', 'center');
        text.setAttribute('position', '0 4 0');
        text.setAttribute('scale', '3 3 3');
        text.setAttribute('color', 'white');
        
        entity.appendChild(arrow);
        entity.appendChild(text);
        container.appendChild(entity);
      });
    }

    function updateARNavigation(userPos) {
      if (!routeCoords.length) return;

      const nextWaypoint = findNextWaypoint(userPos);
      if (!nextWaypoint) return;

      const bearing = calculateBearing(userPos[0], userPos[1], nextWaypoint.lat, nextWaypoint.lng);
      updateDirectionIndicator(bearing);
    }

    function findNextWaypoint(userPos) {
      return routeCoords.reduce((nearest, coord) => {
        const distance = calculateDistance(userPos[0], userPos[1], coord.lat, coord.lng);
        return distance < nearest.distance ? { coord, distance } : nearest;
      }, { coord: null, distance: Infinity }).coord;
    }

    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) -
                Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }

    function updateDirectionIndicator(bearing) {
      let indicator = document.querySelector('.direction-indicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.className = 'direction-indicator';
        document.body.appendChild(indicator);
      }

      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const index = Math.round(bearing / 45) % 8;
      indicator.textContent = `${Math.round(bearing)}° ${directions[index]}`;
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
