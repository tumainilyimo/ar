<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Navigation System</title>

    <!-- Preload critical resources -->
    <link rel="preload" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" as="script">
    <link rel="preload" href="https://aframe.io/releases/1.4.2/aframe.min.js" as="script">

    <!-- Load stylesheets first -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>

    <!-- Load scripts with defer -->
    <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script defer src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script defer src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script defer src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
            font-size: 18px;
            flex-direction: column;
        }

        .loading-spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #2196F3;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .camera-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 1;
        }

        .map-view {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            z-index: 2;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            display: flex;
            gap: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 200px;
            font-size: 14px;
        }

        button {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
            min-width: 100px;
        }

        button:hover {
            background: #1976D2;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .direction-indicator {
            position: fixed;
            bottom: 42%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 3;
            font-size: 16px;
        }

        .instruction-panel {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 3;
            font-size: 16px;
            white-space: nowrap;
        }

        .ar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 5;
            pointer-events: none;
        }

        .ar-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            transition: transform 0.3s ease-out;
        }

        .ar-arrow-head {
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 40px solid rgba(33, 150, 243, 0.9);
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            animation: float 2s infinite ease-in-out;
            transition: border-bottom-color 0.3s ease;
        }

        .wrong-direction .ar-arrow-head {
            border-bottom-color: rgba(255, 0, 0, 0.9);
        }

        @keyframes float {
            0% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
            100% { transform: translateX(-50%) translateY(0); }
        }

        .status-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
        }

        .distance-marker {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            transform: translate(-50%, -150%);
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <div id="loadingText">Initializing System...</div>
    </div>

    <!-- AR Camera View -->
    <div class="camera-view">
        <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix;">
            <a-camera id="ar-camera" gps-camera rotation-reader></a-camera>
            <a-entity id="navigation-points"></a-entity>
        </a-scene>
    </div>

    <!-- AR Overlay -->
    <div class="ar-overlay">
        <div class="ar-arrow" id="navigation-arrow">
            <div class="ar-arrow-head"></div>
        </div>
    </div>

    <!-- Map View -->
    <div class="map-view">
        <div id="map"></div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <input type="text" id="destination" placeholder="Enter your destination">
        <button id="navButton" onclick="startNavigation()" disabled>Navigate</button>
        <button id="recenterButton" onclick="recenterMap()" style="display: none;">Recenter</button>
    </div>

    <!-- Status and Direction Indicators -->
    <div id="direction-panel" class="direction-indicator"></div>
    <div id="instruction-panel" class="instruction-panel"></div>
    <div id="status-indicator" class="status-indicator"></div>

    <script>
        // Global variables
        let map, userMarker, routingControl;
        let routePoints = [];
        let userLocation = null;
        let currentRouteIndex = 0;
        let deviceCompassHeading = null;
        let previousBearing = 0;
        let watchId = null;
        let isNavigating = false;
        let currentInstruction = '';
        let isWrongDirection = false;

        // Resource loading tracking
        let loadingStates = {
            camera: false,
            location: false,
            map: false,
            orientation: false
        };

        function updateLoadingText() {
            const loadingTextElement = document.getElementById('loadingText');
            const remaining = Object.keys(loadingStates).filter(key => !loadingStates[key]);
            if (remaining.length > 0) {
                loadingTextElement.textContent = `Loading: ${remaining.join(', ')}...`;
            } else {
                document.getElementById('loadingOverlay').style.display = 'none';
                document.getElementById('navButton').disabled = false; // Enable navigation once all are loaded
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            initialize();
        });

        async function initialize() {
            try {
                await Promise.all([
                    initializeCamera(),
                    initializeLocation(),
                    initializeDeviceOrientation()
                ]);

                await initializeMap();
                updateStatusIndicator('Ready to navigate');

            } catch (error) {
                console.error('Initialization failed:', error);
                updateStatusIndicator('Initialization failed: ' + error.message);
            }
        }

        // AR Initialization
        async function initializeCamera() {
            return new Promise((resolve, reject) => {
                const scene = document.querySelector('a-scene');
                scene.addEventListener('loaded', () => {
                    loadingStates.camera = true;
                    updateLoadingText();
                    resolve();
                });
                scene.addEventListener('error', (error) => {
                    loadingStates.camera = false;
                    updateLoadingText();
                    reject(new Error('Failed to initialize AR camera: ' + error.message));
                });

                // Fallback in case AR takes too long to load
                setTimeout(() => {
                    if (!loadingStates.camera) {
                        console.warn('AR camera loading timed out.');
                        loadingStates.camera = true; // Mark as loaded to proceed, but potential issues
                        updateLoadingText();
                        resolve();
                    }
                }, 10000); // 10 seconds timeout
            });
        }

        // Location handling
        async function initializeLocation() {
            return new Promise(async (resolve, reject) => {
                try {
                    const permission = await navigator.permissions.query({ name: 'geolocation' });
                    if (permission.state === 'granted') {
                        startLocationTracking();
                        resolve();
                    } else if (permission.state === 'prompt') {
                        navigator.geolocation.getCurrentPosition(() => {
                            startLocationTracking();
                            resolve();
                        }, (error) => {
                            loadingStates.location = false;
                            updateLoadingText();
                            reject(new Error('Location permission denied or error: ' + error.message));
                        });
                    } else {
                        loadingStates.location = false;
                        updateLoadingText();
                        reject(new Error('Location permission not granted.'));
                    }
                } catch (error) {
                    loadingStates.location = false;
                    updateLoadingText();
                    reject(new Error('Error getting location permission: ' + error.message));
                }
            });
        }

        function startLocationTracking() {
            loadingStates.location = true;
            updateLoadingText();
            if (navigator.geolocation) {
                watchId = navigator.geolocation.watchPosition(
                    (position) => {
                        const { latitude, longitude, accuracy } = position.coords;
                        if (accuracy < 20) {
                            userLocation = [latitude, longitude];
                            if (map && !map.hasLayer(userMarker)) {
                                userMarker = L.marker(userLocation, {
                                    icon: L.divIcon({
                                        className: 'user-location-marker',
                                        html: '📍',
                                        iconSize: [25, 25],
                                        iconAnchor: [12, 24]
                                    })
                                }).addTo(map);
                            } else if (userMarker) {
                                userMarker.setLatLng(userLocation);
                            }
                            if (isNavigating) {
                                updateNavigation();
                            }
                        }
                    },
                    (error) => {
                        console.error('Geolocation error:', error);
                        updateStatusIndicator('Geolocation error: ' + error.message);
                        // Consider retrying or informing the user more clearly
                    },
                    {
                        enableHighAccuracy: true,
                        maximumAge: 10000,
                        timeout: 10000
                    }
                );
            } else {
                console.error('Geolocation is not supported by this browser.');
                updateStatusIndicator('Geolocation not supported.');
            }
        }

        // Map initialization
        async function initializeMap() {
            return new Promise((resolve, reject) => {
                if (userLocation) {
                    map = L.map('map', {
                        zoomControl: false,
                        attributionControl: false
                    }).setView(userLocation, 15);

                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        maxZoom: 19,
                        minZoom: 3,
                        updateWhenIdle: false,
                        updateWhenZooming: false,
                        preferCanvas: true
                    }).addTo(map);

                    userMarker = L.marker(userLocation, {
                        icon: L.divIcon({
                            className: 'user-location-marker',
                            html: '📍',
                            iconSize: [25, 25],
                            iconAnchor: [12, 24]
                        })
                    }); // Don't add to map yet, wait for location

                    document.getElementById('recenterButton').style.display = 'inline-block';
                    loadingStates.map = true;
                    updateLoadingText();
                    resolve();
                } else {
                    // Retry map initialization after a short delay if location is not yet available
                    setTimeout(() => {
                        initializeMap().then(resolve).catch(reject);
                    }, 500);
                }
            });
        }

        // Navigation functions
        async function startNavigation() {
            const destination = document.getElementById('destination').value;
            if (!destination) {
                updateStatusIndicator('Please enter a destination');
                return;
            }

            const navButton = document.getElementById('navButton');
            navButton.disabled = true;

            try {
                updateStatusIndicator('Calculating route...');
                const destCoords = await geocodeLocation(destination);
                if (!destCoords) {
                    updateStatusIndicator('Destination not found');
                    navButton.disabled = false;
                    return;
                }

                if (!userLocation) {
                    updateStatusIndicator('Waiting for current location...');
                    return; // Wait for location to be available
                }

                await createRoute(userLocation, destCoords);
                isNavigating = true;
                document.getElementById('recenterButton').style.display = 'inline-block';
            } catch (error) {
                console.error('Navigation error:', error);
                updateStatusIndicator('Error creating route. Please try again.');
            } finally {
                navButton.disabled = false;
            }
        }

        async function geocodeLocation(location) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}&limit=1`
                );
                if (!response.ok) {
                    throw new Error('Geocoding service error');
                }
                const data = await response.json();
                if (data && data.length > 0) {
                    return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
                } else {
                    return null;
                }
            } catch (error) {
                console.error('Geocoding error:', error);
                updateStatusIndicator('Error finding location');
                return null;
            }
        }

        function createRoute(start, end) {
            return new Promise((resolve, reject) => {
                if (routingControl) {
                    map.removeControl(routingControl);
                }

                try {
                    routingControl = L.Routing.control({
                        router: L.Routing.osrmv1({
                            serviceUrl: 'https://router.project-osrm.org/route/v1',
                            profile: 'foot'
                        }),
                        waypoints: [
                            L.latLng(start[0], start[1]),
                            L.latLng(end[0], end[1])
                        ],
                        routeWhileDragging: false,
                        showAlternatives: false,
                        createMarker: () => null,
                        lineOptions: {
                            styles: [{ color: '#2196F3', weight: 6 }]
                        },
                        show: false
                    }).addTo(map);

                    routingControl.on('routesfound', (event) => {
                        if (event.routes.length > 0) {
                            handleRouteFound(event);
                            resolve();
                        } else {
                            reject(new Error('No route found'));
                        }
                    });

                    routingControl.on('routingerror', (err) => {
                        console.error('Routing error:', err);
                        reject(new Error('Route calculation failed'));
                    });

                } catch (error) {
                    console.error('Route creation error:', error);
                    reject(error);
                }
            });
        }

        function handleRouteFound(event) {
            routePoints = event.routes[0].coordinates.map(coord => ({
                lat: coord.lat,
                lng: coord.lng
            }));
            currentRouteIndex = 0;
            const bounds = L.latLngBounds(routePoints);
            map.fitBounds(bounds, { padding: [50, 50] });
            updateNavigation();
            updateStatusIndicator('Route found - Starting navigation');
        }

        function updateNavigation() {
            if (!routePoints.length || !userLocation) return;

            if (currentRouteIndex < routePoints.length - 1) {
                const nextPointCoords = routePoints[currentRouteIndex];
                const distanceToNext = calculateDistance(
                    userLocation,
                    [nextPointCoords.lat, nextPointCoords.lng]
                );

                if (distanceToNext < 10) {
                    currentRouteIndex++;
                    updateStatusIndicator('Reached waypoint - Moving to next');
                }
            }

            const nextPoint = routePoints[currentRouteIndex];
            if (!nextPoint) return;

            updateARElements(nextPoint);
            updateDirectionPanel(nextPoint);
            updateInstructionPanel(nextPoint);
        }

        function updateARElements(nextPoint) {
            const bearing = calculateBearing(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );

            const arrow = document.getElementById('navigation-arrow');
            const userHeading = deviceCompassHeading || 0;
            const rotation = bearing - userHeading;

            const bearingDiff = Math.abs(((bearing - userHeading + 180) % 360) - 180);
            isWrongDirection = bearingDiff > 90;
            arrow.classList.toggle('wrong-direction', isWrongDirection);

            const diff = ((rotation - previousBearing + 180) % 360) - 180;
            const smoothRotation = previousBearing + diff * 0.1;

            arrow.style.transform = `translate(-50%, -50%) rotate(${smoothRotation}deg)`;
            previousBearing = smoothRotation;
        }

        function updateDirectionPanel(nextPoint) {
            const bearing = calculateBearing(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );
            const distance = calculateDistance(userLocation, [nextPoint.lat, nextPoint.lng]);
            const panel = document.getElementById('direction-panel');
            panel.innerHTML = `
                <span style="font-size: 1.2em;">🎯</span>
                ${Math.round(bearing)}°
                <span style="margin: 0 5px;">|</span>
                ${Math.round(distance)}m
            `;
            if (distance < 20) {
                panel.style.backgroundColor = 'rgba(76, 175, 80, 0.9)';
            } else if (distance < 50) {
                panel.style.backgroundColor = 'rgba(255, 152, 0, 0.9)';
            } else {
                panel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
            }
        }

        function updateInstructionPanel(nextPoint) {
            const bearing = calculateBearing(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );
            const distance = calculateDistance(userLocation, [nextPoint.lat, nextPoint.lng]);
            const relativeBearing = ((bearing - (deviceCompassHeading || 0) + 360) % 360);

            let instruction = '';
            let icon = '';

            if (distance < 20) {
                instruction = 'Destination ahead';
                icon = '🏁';
            } else if (isWrongDirection) {
                instruction = 'Wrong direction - Turn around';
                icon = '⚠️';
            } else if (relativeBearing > 330 || relativeBearing < 30) {
                instruction = 'Continue straight ahead';
                icon = '⬆️';
            } else if (relativeBearing < 180) {
                instruction = 'Turn right';
                icon = '↗️';
            } else {
                instruction = 'Turn left';
                icon = '↖️';
            }

            const panel = document.getElementById('instruction-panel');
            panel.innerHTML = `${icon} ${instruction}`;
        }

        // Utility functions
        function calculateDistance(point1, point2) {
            const R = 6371e3; // Earth's radius in meters
            const φ1 = point1[0] * Math.PI/180;
            const φ2 = point2[0] * Math.PI/180;
            const Δφ = (point2[0]-point1[0]) * Math.PI/180;
            const Δλ = (point2[1]-point1[1]) * Math.PI/180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                     Math.cos(φ1) * Math.cos(φ2) *
                     Math.sin(Δλ/2) * Math.sin(Δλ/2);

            return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function calculateBearing(lat1, lon1, lat2, lon2) {
            const φ1 = lat1 * Math.PI/180;
            const φ2 = lat2 * Math.PI/180;
            const Δλ = (lon2-lon1) * Math.PI/180;

            const y = Math.sin(Δλ) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) -
                     Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

            return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
        }

        function recenterMap() {
            if (userLocation) {
                map.setView(userLocation, 18);
            }
        }

        // Device orientation handling
        async function initializeDeviceOrientation() {
            return new Promise((resolve, reject) => {
                if (window.DeviceOrientationEvent) {
                    const handleOrientation = (event) => {
                        let heading;
                        if (event.webkitCompassHeading) {
                            heading = event.webkitCompassHeading;
                        } else if (event.alpha !== null) {
                            heading = 360 - event.alpha;
                        }

                        if (heading !== undefined) {
                            const previousHeading = deviceCompassHeading;
                            deviceCompassHeading = heading;

                            // Smooth compass transitions
                            if (previousHeading !== null) {
                                const headingDiff = ((deviceCompassHeading - previousHeading + 180) % 360) - 180;
                                deviceCompassHeading = previousHeading + headingDiff * 0.3;
                            }

                            if (isNavigating) {
                                updateNavigation();
                            }
                        }
                    };

                    const handlePermission = (permissionState) => {
                        if (permissionState === 'granted') {
                            window.addEventListener('deviceorientation', handleOrientation, true);
                            loadingStates.orientation = true;
                            updateLoadingText();
                            resolve();
                        } else {
                            loadingStates.orientation = false;
                            updateLoadingText();
                            reject(new Error('Device orientation permission not granted.'));
                        }
                    };

                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        DeviceOrientationEvent.requestPermission()
                            .then(handlePermission)
                            .catch(error => {
                                loadingStates.orientation = false;
                                updateLoadingText();
                                reject(new Error('Error requesting device orientation permission: ' + error.message));
                            });
                    } else {
                        window.addEventListener('deviceorientation', handleOrientation, true);
                        loadingStates.orientation = true;
                        updateLoadingText();
                        resolve();
                    }
                } else {
                    loadingStates.orientation = false;
                    updateLoadingText();
                    reject(new Error('Device orientation not supported on this device.'));
                }
            });
        }

        function updateStatusIndicator(message) {
            const indicator = document.getElementById('status-indicator');
            indicator.textContent = message;
            console.log('Status:', message);
        }

        // Handle page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && watchId) {
                navigator.geolocation.clearWatch(watchId);
            } else if (!document.hidden && !watchId && loadingStates.location) {
                startLocationTracking();
            }
        });

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
            }
            window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
        });

        // iOS specific touch event handler for permission (moved inside initializeDeviceOrientation for better flow)

        // Error handling
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            updateStatusIndicator('Error: ' + event.error.message);
        });
    </script>
</body>
</html>
