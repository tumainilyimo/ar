<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Navigation</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; }

        .camera-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 1;
        }

        .map-view {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            z-index: 2;
        }

        #map { width: 100%; height: 100%; }

        .controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            display: flex;
            gap: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
        }

        input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 140px;
        }

        button {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .direction-indicator {
            position: fixed;
            bottom: 42%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 3;
        }

        .ar-direction-container {
            position: absolute;
            top: 30%; /* Adjust vertical position */
            left: 50%;
            transform: translateX(-50%);
            z-index: 4;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .ar-direction-label {
            background-color: rgba(0, 123, 255, 0.8); /* Match blue color */
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            margin-bottom: 5px;
        }

        .ar-arrow {
            display: flex;
        }

        .ar-arrow-segment {
            width: 0;
            height: 0;
            border-top: 15px solid transparent;
            border-bottom: 15px solid transparent;
            border-left: 20px solid white; /* White arrow */
            margin-right: -5px; /* Overlap for connected look */
        }

        .ar-arrow-background {
            width: 0;
            height: 0;
            border-top: 18px solid transparent;
            border-bottom: 18px solid transparent;
            border-left: 25px solid blue; /* Blue background */
            position: relative;
            z-index: -1;
        }

        .ar-emoji {
            font-size: 2em;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="camera-view">
        <a-scene embedded vr-mode-ui="enabled: false" arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3_HAMMING63">
            <a-camera gps-camera rotation-reader look-controls-enabled="false"></a-camera>
            <a-entity id="ar-direction-indicator" class="ar-direction-container" visible="false">
                <a-entity id="ar-direction-label" class="ar-direction-label" text="value: Loading...; align: center"></a-entity>
                <a-entity class="ar-arrow">
                    <a-entity class="ar-arrow-background"></a-entity>
                    <a-entity class="ar-arrow-segment"></a-entity>
                    <a-entity class="ar-arrow-background"></a-entity>
                    <a-entity class="ar-arrow-segment"></a-entity>
                    <a-entity class="ar-arrow-background"></a-entity>
                    <a-entity class="ar-arrow-segment"></a-entity>
                </a-entity>
                <a-entity id="ar-emoji-indicator" class="ar-emoji"></a-entity>
            </a-entity>
        </a-scene>
    </div>

    <div class="map-view">
        <div id="map"></div>
    </div>

    <div class="controls">
        <input type="text" id="start" placeholder="Start location">
        <input type="text" id="end" placeholder="End location">
        <button onclick="calculateRoute()">Route</button>
    </div>

    <div id="direction-panel" class="direction-indicator"></div>

    <script>
        let map, userMarker, routingControl;
        let routePoints = [];
        let userLocation = null;
        let currentRouteIndex = 0; // Track the current waypoint

        window.addEventListener('load', async () => {
            try {
                const position = await getPosition();
                userLocation = [position.coords.latitude, position.coords.longitude];
            } catch (err) {
                console.error('Geolocation error:', err);
                alert('Unable to get your location. Please enable GPS.');
                userLocation = [0, 0];
            }

            initMap();
        });

        function getPosition() {
            return new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 30000,
                    maximumAge: 0
                });
            });
        }

        function initMap() {
            map = L.map('map').setView(userLocation, 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            userMarker = L.marker(userLocation).addTo(map);

            navigator.geolocation.watchPosition(
                (pos) => {
                    userLocation = [pos.coords.latitude, pos.coords.longitude];
                    userMarker.setLatLng(userLocation);
                    updateNavigation();
                },
                console.error,
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 30000
                }
            );
        }

        async function calculateRoute() {
            const start = document.getElementById('start').value;
            const end = document.getElementById('end').value;

            if (!start || !end) {
                alert('Enter both locations');
                return;
            }

            try {
                const startCoords = await geocode(start);
                const endCoords = await geocode(end);

                if (!startCoords || !endCoords) {
                    alert('Location not found');
                    return;
                }

                if (routingControl) {
                    map.removeControl(routingControl);
                }

                routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(startCoords[0], startCoords[1]),
                        L.latLng(endCoords[0], endCoords[1])
                    ],
                    createMarker: () => null,
                    addWaypoints: false
                }).addTo(map);

                routingControl.on('routesfound', event => {
                    routePoints = event.routes[0].coordinates;
                    currentRouteIndex = 0; // Reset route index
                    map.fitBounds(L.latLngBounds(routePoints), {padding: [50, 50]});
                    updateNavigation(); // Call updateNavigation after route is found
                });
            } catch (error) {
                console.error('Route error:', error);
                alert('Route calculation failed');
            }
        }

        async function geocode(location) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}`
                );
                const data = await response.json();
                return data.length ? [parseFloat(data[0].lat), parseFloat(data[0].lon)] : null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }

        function updateNavigation() {
            if (!routePoints.length || !userLocation) return;

            // Move to the next waypoint if close enough to the current one
            if (currentRouteIndex < routePoints.length - 1) {
                const nextPointCoords = routePoints[currentRouteIndex];
                const distanceToNextPoint = calculateDistance(userLocation, [nextPointCoords.lat, nextPointCoords.lng]);
                if (distanceToNextPoint < 10) { // 10 meters threshold
                    currentRouteIndex++;
                }
            }

            const nextPoint = routePoints[currentRouteIndex];
            if (!nextPoint) return;

            const bearing = calculateBearing(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );

            const distance = calculateDistance(userLocation, [nextPoint.lat, nextPoint.lng]);

            document.getElementById('direction-panel').textContent =
                `${Math.round(bearing)}Â° - ${Math.round(distance)}m`;

            updateARDirection(nextPoint.lat, nextPoint.lng);
        }

        function updateARDirection(nextLatitude, nextLongitude) {
            const arContainer = document.getElementById('ar-direction-indicator');
            arContainer.setAttribute('gps-entity-place', `latitude: ${nextLatitude}; longitude: ${nextLongitude}`);
            arContainer.setAttribute('visible', 'true');

            // Update the label with street name (you might need a more robust way to get this)
            getStreetName(nextLatitude, nextLongitude)
                .then(streetName => {
                    document.getElementById('ar-direction-label').setAttribute('text', `value: ${streetName || 'Next Point'}; align: center`);
                })
                .catch(() => {
                    document.getElementById('ar-direction-label').setAttribute('text', `value: Next Point; align: center`);
                });

            const userDirection = getDeviceBearing();
            if (userDirection !== null) {
                const bearingToNextPoint = calculateBearing(userLocation[0], userLocation[1], nextLatitude, nextLongitude);
                let arRotation = bearingToNextPoint - userDirection;
                if (arRotation < 0) {
                    arRotation += 360;
                }
                arContainer.setAttribute('rotation', `0 ${arRotation} 0`);

                // Example of emoji guidance based on distance (can be expanded)
                const distanceToNextPoint = calculateDistance(userLocation, [nextLatitude, nextLongitude]);
                let emoji = '';
                if (distanceToNextPoint < 15) {
                    emoji = 'ð¯'; // Very close
                } else if (distanceToNextPoint < 40) {
                    emoji = 'ð¶'; // Keep going
                } else {
                    emoji = 'ð§­'; // General direction
                }
                document.getElementById('ar-emoji-indicator').setAttribute('text', `value: ${emoji}`);
            }
        }

        async function getStreetName(latitude, longitude) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${latitude}&lon=${longitude}`);
                const data = await response.json();
                if (data && data.address) {
                    return data.address.road || data.address.neighbourhood || data.address.village || data.address.town;
                }
                return null;
            } catch (error) {
                console.error("Error fetching street name:", error);
                return null;
            }
        }

        let deviceCompassHeading = null;
        window.addEventListener('deviceorientation', function(event) {
            deviceCompassHeading = event.webkitCompassHeading || Math.abs(event.alpha - 360);
        });

        function getDeviceBearing() {
            return deviceCompassHeading;
        }

        function findNextPoint() {
            if (routePoints.length === 0) return null;
            return routePoints[currentRouteIndex];
        }

        function calculateDistance(point1, point2) {
            const R = 6371e3;
            const Ï1 = point1[0] * Math.PI/180;
            const Ï2 = point2[0] * Math.PI/180;
            const ÎÏ = (point2[0]-point1[0]) * Math.PI/180;
            const ÎÎ» = (point2[1]-point1[1]) * Math.PI/180;

            const a = Math.sin(ÎÏ/2) * Math.sin(ÎÏ/2) +
                     Math.cos(Ï1) * Math.cos(Ï2) *
                     Math.sin(ÎÎ»/2) * Math.sin(ÎÎ»/2);

            return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function calculateBearing(lat1, lon1, lat2, lon2) {
            const Ï1 = lat1 * Math.PI/180;
            const Ï2 = lat2 * Math.PI/180;
            const ÎÎ» = (lon2-lon1) * Math.PI/180;

            const y = Math.sin(ÎÎ») * Math.cos(Ï2);
            const x = Math.cos(Ï1) * Math.sin(Ï2) -
                     Math.sin(Ï1) * Math.cos(Ï2) * Math.cos(ÎÎ»);

            return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
        }
    </script>
</body>
</html>
