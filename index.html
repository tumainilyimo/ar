<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AR Navigation</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
  <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <style>
    body { margin: 0; padding: 0; font-family: sans-serif; touch-action: pan-y; overflow: hidden; }
    
    .ar-view {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 60vh;
      z-index: 2;
      background: #000;
    }

    .map-container {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 40vh;
      z-index: 1;
    }

    #map { width: 100%; height: 100%; }

    .controls {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      background: rgba(255,255,255,0.8);
      padding: 5px 10px;
      border-radius: 5px;
    }

    .controls input {
      width: 180px;
      padding: 5px;
    }

    .controls button {
      padding: 5px 10px;
      background: #007bff;
      border: none;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
    }

    .controls button:hover {
      background: #0056b3;
    }

    .direction-indicator {
      position: fixed;
      bottom: 45vh;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      z-index: 9999;
    }
  </style>
</head>
<body>
  <div class="ar-view">
    <a-scene embedded vr-mode-ui="enabled: false" arjs="sourceType: webcam; debugUIEnabled: false; trackingMethod: best;">
      <a-camera gps-camera rotation-reader look-controls-enabled="false"></a-camera>
      <a-entity id="routeMarkersContainer"></a-entity>
    </a-scene>
  </div>

  <div class="map-container">
    <div id="map"></div>
  </div>

  <div class="controls">
    <input type="text" id="startLocation" placeholder="Start location"/>
    <input type="text" id="endLocation" placeholder="End location"/>
    <button id="routeBtn">Route</button>
  </div>

  <script>
    let map, userLocationMarker, routeControl;
    let routeCoords = [];
    let userLocation = null;

    window.addEventListener('load', async () => {
      try {
        const position = await getPosition();
        userLocation = [position.coords.latitude, position.coords.longitude];
      } catch (err) {
        console.error('Geolocation error:', err);
        alert('Unable to get your location. Please enable GPS.');
        userLocation = [0, 0];
      }

      initMap();
      document.getElementById('routeBtn').addEventListener('click', handleRoute);
    });

    function initMap() {
      map = L.map('map').setView(userLocation, 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
      userLocationMarker = L.marker(userLocation).addTo(map);

      navigator.geolocation.watchPosition(
        (pos) => {
          userLocation = [pos.coords.latitude, pos.coords.longitude];
          userLocationMarker.setLatLng(userLocation);
          updateAROverlay();
        },
        console.error,
        { 
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 30000
        }
      );
    }

    function getPosition() {
      return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 30000,
          maximumAge: 0
        });
      });
    }

    async function handleRoute() {
      const start = document.getElementById('startLocation').value.trim();
      const end = document.getElementById('endLocation').value.trim();
      
      if (!start || !end) {
        alert('Please enter both locations');
        return;
      }

      try {
        const startCoords = await geocode(start);
        const endCoords = await geocode(end);
        
        if (!startCoords || !endCoords) {
          alert('Location not found');
          return;
        }

        if (routeControl) {
          map.removeControl(routeControl);
        }

        routeControl = L.Routing.control({
          waypoints: [
            L.latLng(startCoords[0], startCoords[1]),
            L.latLng(endCoords[0], endCoords[1])
          ],
          createMarker: () => null,
          showAlternatives: false,
          fitSelectedRoutes: true,
          addWaypoints: false
        })
        .on('routesfound', (evt) => {
          routeCoords = evt.routes[0].coordinates;
          
          const bounds = L.latLngBounds(routeCoords);
          map.fitBounds(bounds, {
            padding: [50, 50],
            maxZoom: 16
          });
          
          createAROverlay();
        })
        .addTo(map);

      } catch (err) {
        console.error('Routing error:', err);
        alert('Error creating route');
      }
    }

    async function geocode(address) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;
      try {
        const response = await fetch(url);
        const data = await response.json();
        if (data && data.length > 0) {
          return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
        }
      } catch (err) {
        console.error('Geocoding error:', err);
      }
      return null;
    }

    function createAROverlay() {
      const container = document.getElementById('routeMarkersContainer');
      container.innerHTML = '';

      routeCoords.forEach((coord, i) => {
        if (i % 5 !== 0) return; // Place marker every 5th coordinate

        const entity = document.createElement('a-entity');
        entity.setAttribute('gps-entity-place', `latitude: ${coord.lat}; longitude: ${coord.lng}`);
        
        const arrow = document.createElement('a-cone');
        arrow.setAttribute('color', '#4285f4');
        arrow.setAttribute('height', '3');
        arrow.setAttribute('radius-bottom', '0.5');
        arrow.setAttribute('position', '0 3 0');
        
        const text = document.createElement('a-text');
        text.setAttribute('value', `${(i + 1)}`);
        text.setAttribute('align', 'center');
        text.setAttribute('position', '0 4 0');
        text.setAttribute('scale', '3 3 3');
        text.setAttribute('color', 'white');
        
        entity.appendChild(arrow);
        entity.appendChild(text);
        container.appendChild(entity);
      });
    }

    function updateAROverlay() {
      if (!routeCoords.length) return;

      const nextWaypoint = findNextWaypoint(userLocation);
      if (!nextWaypoint) return;

      const bearing = getBearing(
        userLocation[0], userLocation[1],
        nextWaypoint.lat, nextWaypoint.lng
      );
      
      updateDirectionIndicator(bearing);
    }

    function findNextWaypoint(pos) {
      return routeCoords.reduce((nearest, coord) => {
        const distance = getDistance(pos[0], pos[1], coord.lat, coord.lng);
        return distance < nearest.distance ? { coord, distance } : nearest;
      }, { coord: null, distance: Infinity }).coord;
    }

    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function getBearing(lat1, lon1, lat2, lon2) {
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) -
                Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

      return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    }

    function updateDirectionIndicator(bearing) {
      let indicator = document.querySelector('.direction-indicator');
      if (!indicator) {
        indicator = document.createElement('div');
        indicator.className = 'direction-indicator';
        document.body.appendChild(indicator);
      }

      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const index = Math.round(bearing / 45) % 8;
      indicator.textContent = `${Math.round(bearing)}° ${directions[index]}`;
    }
  </script>
</body>
</html>
