<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  <title>AR Navigation</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"
  />
  <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    .camera-view {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 60%;
      z-index: 1;
      background: #000;
    }

    .map-view {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 40%;
      z-index: 2;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .controls {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3;
      display: flex;
      gap: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 8px;
    }

    input {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 140px;
    }

    button {
      padding: 8px 16px;
      background: #2196f3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    .direction-indicator {
      position: fixed;
      bottom: 42%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      z-index: 3;
    }

    .ar-direction-container {
      position: absolute;
      top: 30%; /* Adjust vertical position as desired */
      left: 50%;
      transform: translateX(-50%);
      z-index: 4;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .ar-direction-label {
      background-color: rgba(0, 123, 255, 0.8); /* Match blue color */
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      margin-bottom: 5px;
    }

    .ar-arrow {
      display: flex;
    }

    .ar-arrow-segment {
      width: 0;
      height: 0;
      border-top: 15px solid transparent;
      border-bottom: 15px solid transparent;
      border-left: 20px solid white; /* White arrow */
      margin-right: -5px; /* Overlap for connected look */
    }

    .ar-arrow-background {
      width: 0;
      height: 0;
      border-top: 18px solid transparent;
      border-bottom: 18px solid transparent;
      border-left: 25px solid blue; /* Blue background */
      position: relative;
      z-index: -1;
    }

    .ar-emoji {
      font-size: 2em;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <!-- CAMERA/AR VIEW -->
  <div class="camera-view">
    <a-scene
      embedded
      vr-mode-ui="enabled: false"
      arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3_HAMMING63"
    >
      <!-- Use the gps-camera to get geolocation-based AR positioning. -->
      <a-camera gps-camera rotation-reader look-controls-enabled="false">
      </a-camera>

      <!-- AR direction indicator: we place it at the user's location and rotate it toward the next waypoint. -->
      <a-entity
        id="ar-direction-indicator"
        class="ar-direction-container"
        gps-entity-place="latitude: 0; longitude: 0"
        visible="false"
      >
        <a-entity
          class="ar-direction-label"
          text="value: ; align: center"
        ></a-entity>
        <a-entity class="ar-arrow">
          <a-entity class="ar-arrow-background"></a-entity>
          <a-entity class="ar-arrow-segment"></a-entity>
          <a-entity class="ar-arrow-background"></a-entity>
          <a-entity class="ar-arrow-segment"></a-entity>
          <a-entity class="ar-arrow-background"></a-entity>
          <a-entity class="ar-arrow-segment"></a-entity>
        </a-entity>
        <a-entity id="ar-emoji-indicator" class="ar-emoji"></a-entity>
      </a-entity>
    </a-scene>
  </div>

  <!-- MAP VIEW -->
  <div class="map-view">
    <div id="map"></div>
  </div>

  <!-- CONTROLS (ROUTING) -->
  <div class="controls">
    <input type="text" id="start" placeholder="Start location" />
    <input type="text" id="end" placeholder="End location" />
    <button onclick="calculateRoute()">Route</button>
  </div>

  <!-- DIRECTION PANEL (TEXT) -->
  <div id="direction-panel" class="direction-indicator"></div>

  <script>
    let map, userMarker, routingControl;
    let routePoints = [];
    let userLocation = null;
    let deviceCompassHeading = null;
    let currentRouteIndex = 0; // We'll move through the route step by step.

    window.addEventListener("load", async () => {
      try {
        const position = await getPosition();
        userLocation = [position.coords.latitude, position.coords.longitude];
      } catch (err) {
        console.error("Geolocation error:", err);
        alert("Unable to get your location. Please enable GPS.");
        userLocation = [0, 0];
      }

      initMap();
    });

    /**
     * Retrieve current position (GPS)
     */
    function getPosition() {
      return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 30000,
          maximumAge: 0,
        });
      });
    }

    /**
     * Initialize Leaflet map
     */
    function initMap() {
      map = L.map("map").setView(userLocation, 15);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png").addTo(
        map
      );
      userMarker = L.marker(userLocation).addTo(map);

      // Watch user location changes in real time
      navigator.geolocation.watchPosition(
        (pos) => {
          userLocation = [pos.coords.latitude, pos.coords.longitude];
          userMarker.setLatLng(userLocation);
          updateNavigation();
        },
        console.error,
        {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 30000,
        }
      );
    }

    /**
     * Geocode using Nominatim
     */
    async function geocode(location) {
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
            location
          )}`
        );
        const data = await response.json();
        return data.length ? [parseFloat(data[0].lat), parseFloat(data[0].lon)] : null;
      } catch (error) {
        console.error("Geocoding error:", error);
        return null;
      }
    }

    /**
     * Calculate the route using Leaflet Routing Machine
     */
    async function calculateRoute() {
      const start = document.getElementById("start").value;
      const end = document.getElementById("end").value;

      if (!start || !end) {
        alert("Enter both locations");
        return;
      }

      try {
        const startCoords = await geocode(start);
        const endCoords = await geocode(end);

        if (!startCoords || !endCoords) {
          alert("Location not found");
          return;
        }

        if (routingControl) {
          map.removeControl(routingControl);
        }

        routingControl = L.Routing.control({
          waypoints: [
            L.latLng(startCoords[0], startCoords[1]),
            L.latLng(endCoords[0], endCoords[1]),
          ],
          createMarker: () => null,
          addWaypoints: false,
        }).addTo(map);

        // On route found
        routingControl.on("routesfound", (event) => {
          const route = event.routes[0];
          routePoints = route.coordinates;
          currentRouteIndex = 0; // Start at beginning of route
          map.fitBounds(L.latLngBounds(routePoints), { padding: [50, 50] });
          updateNavigation(); // Initialize AR arrow
        });
      } catch (error) {
        console.error("Route error:", error);
        alert("Route calculation failed");
      }
    }

    /**
     * Called whenever user location changes or a new route is calculated
     */
    function updateNavigation() {
      if (!routePoints.length || !userLocation) return;

      // If we're near the "current" route point, advance to the next
      const distanceToCurrent = calculateDistance(userLocation, [
        routePoints[currentRouteIndex].lat,
        routePoints[currentRouteIndex].lng,
      ]);
      if (distanceToCurrent < 10) {
        // 10 meters threshold; adjust as desired
        currentRouteIndex++;
        if (currentRouteIndex >= routePoints.length) {
          // End of route
          document.getElementById("direction-panel").textContent =
            "You have arrived!";
          hideArrow();
          return;
        }
      }

      const nextPoint = routePoints[currentRouteIndex];
      if (!nextPoint) return;

      // Bearing from user to next waypoint
      const bearingToNextPoint = calculateBearing(
        userLocation[0],
        userLocation[1],
        nextPoint.lat,
        nextPoint.lng
      );

      // Distance to next waypoint
      const distanceToNextPoint = calculateDistance(userLocation, [
        nextPoint.lat,
        nextPoint.lng,
      ]);

      // Display textual info
      document.getElementById("direction-panel").textContent = `Bearing: ${Math.round(
        bearingToNextPoint
      )}掳 | Distance: ${Math.round(distanceToNextPoint)} m`;

      // Now update the AR arrow
      updateARDirection(nextPoint, bearingToNextPoint, distanceToNextPoint);
    }

    /**
     * Position and rotate the AR arrow in the scene
     */
    function updateARDirection(nextPoint, bearingToNextPoint, distanceToNext) {
      const arContainer = document.getElementById("ar-direction-indicator");
      arContainer.setAttribute("visible", "true");

      // Place arrow at the user's location in AR
      arContainer.setAttribute(
        "gps-entity-place",
        `latitude: ${userLocation[0]}; longitude: ${userLocation[1]}`
      );

      // Determine device heading, if available
      const userHeading = getDeviceBearing();
      if (userHeading === null) {
        // If no heading yet, default to 0
        arContainer.setAttribute("rotation", `0 0 0`);
      } else {
        // The arrow's rotation is how much we must turn from the devices facing
        let arrowRotation = bearingToNextPoint - userHeading;
        if (arrowRotation < 0) {
          arrowRotation += 360;
        }
        arContainer.setAttribute("rotation", `0 ${arrowRotation} 0`);
      }

      // Label with the street name or next location if desired
      // (Hard-coded text below can be replaced with your actual street name data.)
      const labelEntity = arContainer.querySelector(".ar-direction-label");
      labelEntity.setAttribute("text", "value: Next waypoint; align: center");

      // Example emoji guidance
      let emoji = "";
      if (distanceToNext < 20) {
        emoji = ""; // Very close
      } else if (distanceToNext < 50) {
        emoji = ""; // Keep going
      } else {
        emoji = "Л"; // General direction
      }
      document
        .getElementById("ar-emoji-indicator")
        .setAttribute("text", `value: ${emoji}`);
    }

    /**
     * Hide AR arrow (e.g., if route is done)
     */
    function hideArrow() {
      const arContainer = document.getElementById("ar-direction-indicator");
      arContainer.setAttribute("visible", "false");
    }

    /**
     * Listen for device orientation events (compass heading)
     */
    window.addEventListener("deviceorientation", function (event) {
      // iOS-specific: event.webkitCompassHeading
      if (event.webkitCompassHeading !== undefined) {
        deviceCompassHeading = event.webkitCompassHeading;
      } else {
        // For Android: alpha is 0 at North, 90 at East, so we convert
        // The exact math may vary by device; you might also do (360 - alpha)
        let alpha = event.alpha;
        if (alpha !== null) {
          // If the phone is flat on a table, alpha could be 0. 
          // Tweak logic if needed for your device orientation test.
          const heading = 360 - alpha; 
          deviceCompassHeading = heading < 0 ? heading + 360 : heading;
        }
      }
    });

    /**
     * Get the last known device compass heading
     */
    function getDeviceBearing() {
      return deviceCompassHeading;
    }

    /**
     * Great-circle distance (in meters) between two lat-lon points
     */
    function calculateDistance(point1, point2) {
      const R = 6371e3; // metres
      const 1 = (point1[0] * Math.PI) / 180;
      const 2 = (point2[0] * Math.PI) / 180;
      const  = ((point2[0] - point1[0]) * Math.PI) / 180;
      const 位 = ((point2[1] - point1[1]) * Math.PI) / 180;

      const a =
        Math.sin( / 2) * Math.sin( / 2) +
        Math.cos(1) *
          Math.cos(2) *
          Math.sin(位 / 2) *
          Math.sin(位 / 2);

      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    /**
     * Bearing from (lat1, lon1) to (lat2, lon2) in degrees (0 = North)
     */
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const 1 = (lat1 * Math.PI) / 180;
      const 2 = (lat2 * Math.PI) / 180;
      const 位 = ((lon2 - lon1) * Math.PI) / 180;

      const y = Math.sin(位) * Math.cos(2);
      const x =
        Math.cos(1) * Math.sin(2) -
        Math.sin(1) * Math.cos(2) * Math.cos(位);

      const bearing = (Math.atan2(y, x) * 180) / Math.PI;
      // Normalize to 0-360
      return (bearing + 360) % 360;
    }
  </script>
</body>
</html>
