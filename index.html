<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AR Navigation</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
  <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <style>
    body { 
      margin: 0; 
      padding: 0;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
    }

    #camera-view {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 60%;
      z-index: 1;
    }

    #map-view {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 40%;
      z-index: 2;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .controls {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      display: flex;
      gap: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 8px;
    }

    .controls input {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 150px;
    }

    .controls button {
      padding: 8px 16px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    #direction-panel {
      position: fixed;
      bottom: 45%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      z-index: 1000;
    }

    .instructions {
      position: absolute;
      right: 0;
      top: 0;
      width: 250px;
      height: 100%;
      background: rgba(255,255,255,0.9);
      overflow-y: auto;
      padding: 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Camera View with AR -->
  <div id="camera-view">
    <a-scene 
      embedded
      arjs='sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;'
      vr-mode-ui="enabled: false"
    >
      <a-camera gps-projected-camera rotation-reader></a-camera>
      <a-entity id="route-markers"></a-entity>
    </a-scene>
    
    <div class="controls">
      <input type="text" id="start-input" placeholder="Start location">
      <input type="text" id="end-input" placeholder="End location">
      <button onclick="calculateRoute()">Route</button>
    </div>

    <div id="direction-panel"></div>
  </div>

  <!-- Map View -->
  <div id="map-view">
    <div id="map"></div>
    <div class="instructions" id="instructions"></div>
  </div>

  <script>
    let map, userMarker, routingControl;
    let userLocation = null;
    let routePoints = [];

    // Initialize on page load
    window.onload = async () => {
      try {
        const pos = await getCurrentPosition();
        userLocation = [pos.coords.latitude, pos.coords.longitude];
        initializeMap();
        startLocationWatch();
      } catch (error) {
        console.error('Location error:', error);
        userLocation = [-3.3667, 36.6833]; // Arusha fallback
        initializeMap();
      }
    };

    function getCurrentPosition() {
      return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 30000,
          maximumAge: 0
        });
      });
    }

    function initializeMap() {
      map = L.map('map').setView(userLocation, 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
      userMarker = L.marker(userLocation).addTo(map);
    }

    function startLocationWatch() {
      navigator.geolocation.watchPosition(
        position => {
          userLocation = [position.coords.latitude, position.coords.longitude];
          userMarker.setLatLng(userLocation);
          updateARNavigation();
        },
        error => console.error('Watch position error:', error),
        { enableHighAccuracy: true }
      );
    }

    async function calculateRoute() {
      const start = document.getElementById('start-input').value;
      const end = document.getElementById('end-input').value;

      if (!start || !end) {
        alert('Please enter both locations');
        return;
      }

      try {
        const startCoords = await geocodeLocation(start);
        const endCoords = await geocodeLocation(end);
        
        if (!startCoords || !endCoords) {
          alert('Location not found');
          return;
        }

        if (routingControl) {
          map.removeControl(routingControl);
        }

        routingControl = L.Routing.control({
          waypoints: [
            L.latLng(startCoords[0], startCoords[1]),
            L.latLng(endCoords[0], endCoords[1])
          ],
          routeWhileDragging: false,
          createMarker: () => null
        }).addTo(map);

        routingControl.on('routesfound', event => {
          const route = event.routes[0];
          routePoints = route.coordinates;
          
          // Update instructions
          document.getElementById('instructions').innerHTML = 
            route.instructions.map(instruction => 
              `<div style="padding: 8px 0; border-bottom: 1px solid #eee;">
                ${instruction.text} (${instruction.distance}m)
               </div>`
            ).join('');

          // Fit map to route
          map.fitBounds(L.latLngBounds(route.coordinates), { padding: [50, 50] });
          
          createARMarkers();
        });
      } catch (error) {
        console.error('Route calculation error:', error);
        alert('Error calculating route');
      }
    }

    async function geocodeLocation(address) {
      try {
        const response = await fetch(
          `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`
        );
        const data = await response.json();
        return data.length ? [parseFloat(data[0].lat), parseFloat(data[0].lon)] : null;
      } catch (error) {
        console.error('Geocoding error:', error);
        return null;
      }
    }

    function createARMarkers() {
      const container = document.getElementById('route-markers');
      container.innerHTML = '';

      routePoints.forEach((point, index) => {
        if (index % 5 !== 0) return; // Place marker every 5th point

        const marker = document.createElement('a-sphere');
        marker.setAttribute('gps-projected-entity-place', {
          latitude: point.lat,
          longitude: point.lng
        });
        marker.setAttribute('radius', '1');
        marker.setAttribute('color', '#2196F3');
        marker.setAttribute('position', '0 2 0');

        const text = document.createElement('a-text');
        text.setAttribute('value', `${Math.round(index/5 + 1)}`);
        text.setAttribute('look-at', '[gps-projected-camera]');
        text.setAttribute('scale', '5 5 5');
        text.setAttribute('align', 'center');
        text.setAttribute('position', '0 2 0');

        container.appendChild(marker);
        container.appendChild(text);
      });
    }

    function updateARNavigation() {
      if (!routePoints.length || !userLocation) return;

      const nextPoint = findNextRoutePoint();
      if (!nextPoint) return;

      const bearing = calculateBearing(userLocation, [nextPoint.lat, nextPoint.lng]);
      const distance = calculateDistance(userLocation, [nextPoint.lat, nextPoint.lng]);

      document.getElementById('direction-panel').textContent = 
        `${Math.round(bearing)}° - ${Math.round(distance)}m`;
    }

    function findNextRoutePoint() {
      return routePoints.reduce((nearest, point) => {
        const distance = calculateDistance(
          userLocation, 
          [point.lat, point.lng]
        );
        return distance < nearest.distance ? {point, distance} : nearest;
      }, {point: null, distance: Infinity}).point;
    }

    function calculateDistance(point1, point2) {
      const R = 6371e3;
      const φ1 = point1[0] * Math.PI/180;
      const φ2 = point2[0] * Math.PI/180;
      const Δφ = (point2[0] - point1[0]) * Math.PI/180;
      const Δλ = (point2[1] - point1[1]) * Math.PI/180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function calculateBearing(point1, point2) {
      const φ1 = point1[0] * Math.PI/180;
      const φ2 = point2[0] * Math.PI/180;
      const Δλ = (point2[1] - point1[1]) * Math.PI/180;

      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) -
                Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

      return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
    }
  </script>
</body>
</html>
