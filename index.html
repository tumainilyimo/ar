<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Navigation</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        
        .camera-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 1;
        }

        .map-view {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            z-index: 2;
        }

        #map { width: 100%; height: 100%; }

        .controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            display: flex;
            gap: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
        }

        input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 140px;
        }

        button {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .direction-indicator {
            position: fixed;
            bottom: 42%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 3;
        }
    </style>
</head>
<body>
    <div class="camera-view">
        <a-scene embedded vr-mode-ui="enabled: false" arjs="sourceType: webcam; debugUIEnabled: false;">
            <a-camera gps-camera rotation-reader look-controls-enabled="false"></a-camera>
            <a-entity id="route-markers"></a-entity>
        </a-scene>
    </div>

    <div class="map-view">
        <div id="map"></div>
    </div>

    <div class="controls">
        <input type="text" id="start" placeholder="Start location">
        <input type="text" id="end" placeholder="End location">
        <button onclick="calculateRoute()">Route</button>
    </div>

    <div id="direction-panel" class="direction-indicator"></div>

    <script>
        let map, userMarker, routingControl;
        let routePoints = [];
        let userLocation = null;

        window.addEventListener('load', async () => {
            try {
                const position = await getPosition();
                userLocation = [position.coords.latitude, position.coords.longitude];
            } catch (err) {
                console.error('Geolocation error:', err);
                alert('Unable to get your location. Please enable GPS.');
                userLocation = [0, 0];
            }

            initMap();
        });

        function getPosition() {
            return new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 30000,
                    maximumAge: 0
                });
            });
        }

        function initMap() {
            map = L.map('map').setView(userLocation, 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            userMarker = L.marker(userLocation).addTo(map);

            navigator.geolocation.watchPosition(
                (pos) => {
                    userLocation = [pos.coords.latitude, pos.coords.longitude];
                    userMarker.setLatLng(userLocation);
                    updateNavigation();
                },
                console.error,
                { 
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 30000
                }
            );
        }

        async function calculateRoute() {
            const start = document.getElementById('start').value;
            const end = document.getElementById('end').value;

            if (!start || !end) {
                alert('Enter both locations');
                return;
            }

            try {
                const startCoords = await geocode(start);
                const endCoords = await geocode(end);

                if (!startCoords || !endCoords) {
                    alert('Location not found');
                    return;
                }

                if (routingControl) {
                    map.removeControl(routingControl);
                }

                routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(startCoords[0], startCoords[1]),
                        L.latLng(endCoords[0], endCoords[1])
                    ],
                    createMarker: () => null,
                    addWaypoints: false
                }).addTo(map);

                routingControl.on('routesfound', event => {
                    routePoints = event.routes[0].coordinates;
                    map.fitBounds(L.latLngBounds(routePoints), {padding: [50, 50]});
                    updateARMarkers();
                });
            } catch (error) {
                console.error('Route error:', error);
                alert('Route calculation failed');
            }
        }

        async function geocode(location) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}`
                );
                const data = await response.json();
                return data.length ? [parseFloat(data[0].lat), parseFloat(data[0].lon)] : null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }

        function updateARMarkers() {
            const container = document.getElementById('route-markers');
            container.innerHTML = '';

            routePoints.forEach((point, index) => {
                if (index % 5 === 0) {
                    const entity = document.createElement('a-entity');
                    entity.setAttribute('gps-entity-place', `latitude: ${point.lat}; longitude: ${point.lng}`);
                    
                    const arrow = document.createElement('a-cone');
                    arrow.setAttribute('color', '#4285f4');
                    arrow.setAttribute('height', '15');
                    arrow.setAttribute('radius-bottom', '3');
                    arrow.setAttribute('position', '0 15 0');
                    arrow.setAttribute('material', 'opacity: 0.8');
                    arrow.setAttribute('animation', 'property: position; to: 0 20 0; dur: 2000; easing: easeInOutQuad; loop: true; dir: alternate');

                    const text = document.createElement('a-text');
                    text.setAttribute('value', `${Math.round(index/5 + 1)}`);
                    text.setAttribute('align', 'center');
                    text.setAttribute('position', '0 25 0');
                    text.setAttribute('scale', '10 10 10');
                    text.setAttribute('color', 'white');
                    text.setAttribute('look-at', '[gps-camera]');

                    entity.appendChild(arrow);
                    entity.appendChild(text);
                    container.appendChild(entity);
                }
            });
        }

        function updateNavigation() {
            if (!routePoints.length || !userLocation) return;

            const nextPoint = findNextPoint();
            if (!nextPoint) return;

            const bearing = calculateBearing(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );

            const distance = calculateDistance(userLocation, [nextPoint.lat, nextPoint.lng]);
            
            document.getElementById('direction-panel').textContent = 
                `${Math.round(bearing)}° - ${Math.round(distance)}m`;
        }

        function findNextPoint() {
            return routePoints.reduce((nearest, point) => {
                const distance = calculateDistance(userLocation, [point.lat, point.lng]);
                return distance < nearest.distance ? {point, distance} : nearest;
            }, {point: null, distance: Infinity}).point;
        }

        function calculateDistance(point1, point2) {
            const R = 6371e3;
            const φ1 = point1[0] * Math.PI/180;
            const φ2 = point2[0] * Math.PI/180;
            const Δφ = (point2[0]-point1[0]) * Math.PI/180;
            const Δλ = (point2[1]-point1[1]) * Math.PI/180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                     Math.cos(φ1) * Math.cos(φ2) *
                     Math.sin(Δλ/2) * Math.sin(Δλ/2);
            
            return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function calculateBearing(lat1, lon1, lat2, lon2) {
            const φ1 = lat1 * Math.PI/180;
            const φ2 = lat2 * Math.PI/180;
            const Δλ = (lon2-lon1) * Math.PI/180;

            const y = Math.sin(Δλ) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) -
                     Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

            return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
        }
    </script>
</body>
</html>
