<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Navigation System</title>

    <!-- External Libraries -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }

        .camera-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 1;
        }

        .map-view {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            z-index: 2;
        }

        #map { 
            width: 100%; 
            height: 100%; 
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            display: flex;
            gap: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 140px;
            font-size: 14px;
        }

        button {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        button:hover {
            background: #1976D2;
        }

        .direction-indicator {
            position: fixed;
            bottom: 42%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 3;
            font-size: 16px;
        }

        .ar-navigation-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            pointer-events: none;
            z-index: 4;
        }

        .ar-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            transition: transform 0.3s ease-out;
        }

        .ar-arrow-head {
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-bottom: 40px solid rgba(33, 150, 243, 0.9);
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            animation: float 2s infinite ease-in-out;
        }

        .ar-navigation-point {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: rgba(33, 150, 243, 0.8);
            border-radius: 50%;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
        }

        .distance-marker {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            transform: translate(-50%, -150%);
            white-space: nowrap;
        }

        @keyframes float {
            0% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
            100% { transform: translateX(-50%) translateY(0); }
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.7; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        .status-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
        }

        .ar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 5;
            pointer-events: none;
        }

        .navigation-point {
            position: absolute;
            width: 30px;
            height: 30px;
            background: rgba(33, 150, 243, 0.8);
            border-radius: 50%;
            border: 3px solid white;
            transform: translate(-50%, -50%);
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <!-- AR Camera View -->
    <div class="camera-view">
        <a-scene embedded arjs='sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix;'>
            <a-camera gps-camera rotation-reader></a-camera>
            <a-entity id="navigation-points"></a-entity>
        </a-scene>
    </div>

    <!-- AR Overlay for dynamic elements -->
    <div class="ar-overlay">
        <div class="ar-arrow" id="navigation-arrow">
            <div class="ar-arrow-head"></div>
        </div>
    </div>

    <!-- Map View -->
    <div class="map-view">
        <div id="map"></div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <input type="text" id="start" placeholder="Start location">
        <input type="text" id="end" placeholder="End location">
        <button onclick="calculateRoute()">Navigate</button>
    </div>

    <!-- Status and Direction Indicators -->
    <div id="direction-panel" class="direction-indicator"></div>
    <div id="status-indicator" class="status-indicator"></div>

    <script>
        // Global variables
        let map, userMarker, routingControl;
        let routePoints = [];
        let userLocation = null;
        let currentRouteIndex = 0;
        let deviceCompassHeading = null;
        let previousBearing = 0;
        let watchId = null;
        let isNavigating = false;

        // Initialize application
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await initializeAR();
                await requestPermissions();
                const position = await getCurrentPosition();
                userLocation = [position.coords.latitude, position.coords.longitude];
                initializeMap();
                startLocationTracking();
                initializeDeviceOrientation();
                updateStatusIndicator('Ready to navigate');
            } catch (error) {
                console.error('Initialization error:', error);
                updateStatusIndicator('Error: ' + error.message);
            }
        });

        // AR Initialization
        async function initializeAR() {
            return new Promise((resolve) => {
                const scene = document.querySelector('a-scene');
                if (scene.hasLoaded) {
                    resolve();
                } else {
                    scene.addEventListener('loaded', resolve);
                }
            });
        }

        // Permission handling
        async function requestPermissions() {
            try {
                const results = await Promise.all([
                    navigator.permissions.query({ name: 'geolocation' }),
                    DeviceOrientationEvent.requestPermission?.() || Promise.resolve('granted')
                ]);
                
                const [geoPermission] = results;
                if (geoPermission.state === 'granted') {
                    return true;
                }
                throw new Error('Location permission denied');
            } catch (error) {
                console.warn('Permission request error:', error);
                throw error;
            }
        }

        // Geolocation handling
        function getCurrentPosition() {
            return new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                });
            });
        }

        function startLocationTracking() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
            }

            watchId = navigator.geolocation.watchPosition(
                updateUserLocation,
                handleLocationError,
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 5000
                }
            );
        }

        function updateUserLocation(position) {
            userLocation = [position.coords.latitude, position.coords.longitude];
            if (userMarker) {
                userMarker.setLatLng(userLocation);
            }
            if (isNavigating) {
                updateNavigation();
            }
        }

        function handleLocationError(error) {
            console.error('Location error:', error);
            updateStatusIndicator('Location error: ' + error.message);
        }

        // Map initialization
        function initializeMap() {
            map = L.map('map').setView(userLocation, 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(map);
            
            userMarker = L.marker(userLocation, {
                icon: L.divIcon({
                    className: 'user-location-marker',
                    html: '📍',
                    iconSize: [25, 25],
                    iconAnchor: [12, 24]
                })
            }).addTo(map);
        }

        // Route calculation
        async function calculateRoute() {
            const startInput = document.getElementById('start').value;
            const endInput = document.getElementById('end').value;

            if (!startInput || !endInput) {
                updateStatusIndicator('Please enter both locations');
                return;
            }

            try {
                updateStatusIndicator('Calculating route...');
                const startCoords = await geocodeLocation(startInput);
                const endCoords = await geocodeLocation(endInput);

                if (!startCoords || !endCoords) {
                    updateStatusIndicator('Location not found');
                    return;
                }

                await createRoute(startCoords, endCoords);
                isNavigating = true;
            } catch (error) {
                console.error('Route calculation error:', error);
                updateStatusIndicator('Route calculation failed');
            }
        }

        async function geocodeLocation(location) {
            try {
                const response = await fetch(
                    `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}`
                );
                const data = await response.json();
                return data.length ? [parseFloat(data[0].lat), parseFloat(data[0].lon)] : null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }

        function createRoute(start, end) {
            return new Promise((resolve, reject) => {
                if (routingControl) {
                    map.removeControl(routingControl);
                }

                routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(start[0], start[1]),
                        L.latLng(end[0], end[1])
                    ],
                    routeWhileDragging: false,
                    showAlternatives: false,
                    createMarker: () => null
                }).addTo(map);

                routingControl.on('routesfound', (event) => {
                    handleRouteFound(event);
                    resolve(event);
                });

                routingControl.on('routingerror', (error) => {
                    reject(error);
                });
            });
        }

        function handleRouteFound(event) {
            routePoints = event.routes[0].coordinates;
            currentRouteIndex = 0;
            map.fitBounds(L.latLngBounds(routePoints), { padding: [50, 50] });
            updateNavigation();
            updateStatusIndicator('Route found - Starting navigation');
        }

        // Navigation updates
        function updateNavigation() {
            if (!routePoints.length || !userLocation) return;

            // Check for waypoint progression
            if (currentRouteIndex < routePoints.length - 1) {
                const nextPointCoords = routePoints[currentRouteIndex];
                const distanceToNext = calculateDistance(
                    userLocation,
                    [nextPointCoords.lat, nextPointCoords.lng]
                );

                if (distanceToNext < 10) { // 10 meters threshold
                    currentRouteIndex++;
                    updateStatusIndicator('Reached waypoint - Moving to next');
                }
            }

            const nextPoint = routePoints[currentRouteIndex];
            if (!nextPoint) return;

            updateARElements(nextPoint);
            updateDirectionPanel(nextPoint);
        }

        function updateARElements(nextPoint) {
            // Update AR arrow
            const bearing = calculateBearing(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );

            const arrow = document.getElementById('navigation-arrow');
            const rotation = bearing - (deviceCompassHeading || 0);
            
            // Smooth rotation
            const diff = ((rotation - previousBearing + 180) % 360) - 180;
            const smoothRotation = previousBearing + diff * 0.1;
            
            // Continue from the arrow update
            arrow.style.transform = `translate(-50%, -50%) rotate(${smoothRotation}deg)`;
            previousBearing = smoothRotation;

            // Update AR navigation points
            const container = document.getElementById('navigation-points');
            container.innerHTML = '';

            // Calculate and display next visible waypoints
            const visiblePoints = Math.min(3, routePoints.length - currentRouteIndex);
            for (let i = 0; i < visiblePoints; i++) {
                const pointIndex = currentRouteIndex + i;
                const point = routePoints[pointIndex];
                
                // Create AR entity for the point
                const entity = document.createElement('a-entity');
                const distance = calculateDistance(userLocation, [point.lat, point.lng]);
                
                // Set point attributes
                entity.setAttribute('nav-point', {
                    latitude: point.lat,
                    longitude: point.lng,
                    distance: distance,
                    index: i
                });
                
                entity.setAttribute('gps-entity-place', {
                    latitude: point.lat,
                    longitude: point.lng
                });

                // Add progress indicator if it's the active point
                if (i === 0) {
                    entity.setAttribute('active-point', '');
                }
                
                container.appendChild(entity);
            }
        }

        // Custom A-Frame component for navigation points
        AFRAME.registerComponent('nav-point', {
            schema: {
                latitude: { type: 'number', default: 0 },
                longitude: { type: 'number', default: 0 },
                distance: { type: 'number', default: 0 },
                index: { type: 'number', default: 0 }
            },

            init: function() {
                this.createPoint();
                this.createLabel();
                this.createDistanceIndicator();
                this.setupAnimations();
            },

            createPoint: function() {
                // Create the main point geometry
                this.el.setAttribute('geometry', {
                    primitive: 'sphere',
                    radius: 0.5 - (this.data.index * 0.1) // Smaller points for further waypoints
                });

                // Set material with different colors based on index
                const colors = ['#2196F3', '#64B5F6', '#90CAF9'];
                this.el.setAttribute('material', {
                    color: colors[this.data.index] || colors[colors.length - 1],
                    opacity: 0.8 - (this.data.index * 0.1),
                    transparent: true
                });
            },

            createLabel: function() {
                const label = document.createElement('a-entity');
                const distance = Math.round(this.data.distance);
                
                // Create text label
                const text = document.createElement('a-text');
                text.setAttribute('value', `${distance}m`);
                text.setAttribute('align', 'center');
                text.setAttribute('position', '0 0.7 0');
                text.setAttribute('scale', '0.7 0.7 0.7');
                text.setAttribute('color', 'white');
                text.setAttribute('look-at', '[camera]');

                // Add background panel for better visibility
                const background = document.createElement('a-plane');
                background.setAttribute('position', '0 0.7 -0.01');
                background.setAttribute('color', '#000');
                background.setAttribute('opacity', '0.5');
                background.setAttribute('height', '0.3');
                background.setAttribute('width', '0.8');

                label.appendChild(background);
                label.appendChild(text);
                this.el.appendChild(label);
            },

            createDistanceIndicator: function() {
                if (this.data.index === 0) {
                    const progressRing = document.createElement('a-ring');
                    progressRing.setAttribute('radius-inner', '0.6');
                    progressRing.setAttribute('radius-outer', '0.7');
                    progressRing.setAttribute('color', '#4CAF50');
                    progressRing.setAttribute('rotation', '90 0 0');
                    this.el.appendChild(progressRing);
                }
            },

            setupAnimations: function() {
                // Pulse animation
                this.el.setAttribute('animation__scale', {
                    property: 'scale',
                    dir: 'alternate',
                    dur: 1000 + (this.data.index * 200),
                    easing: 'easeInOutQuad',
                    loop: true,
                    from: '1 1 1',
                    to: '1.2 1.2 1.2'
                });

                // Fade animation
                this.el.setAttribute('animation__opacity', {
                    property: 'material.opacity',
                    dir: 'alternate',
                    dur: 1000 + (this.data.index * 200),
                    easing: 'easeInOutQuad',
                    loop: true,
                    from: 0.8 - (this.data.index * 0.1),
                    to: 0.4 - (this.data.index * 0.1)
                });
            }
        });

        // Active point component for the current waypoint
        AFRAME.registerComponent('active-point', {
            init: function() {
                this.setupActiveIndicator();
            },

            setupActiveIndicator: function() {
                // Add active indicator ring
                const activeRing = document.createElement('a-ring');
                activeRing.setAttribute('radius-inner', '0.8');
                activeRing.setAttribute('radius-outer', '0.9');
                activeRing.setAttribute('color', '#FFD700');
                activeRing.setAttribute('rotation', '90 0 0');
                
                // Add rotation animation
                activeRing.setAttribute('animation', {
                    property: 'rotation',
                    dur: 3000,
                    easing: 'linear',
                    loop: true,
                    to: '90 360 0'
                });

                this.el.appendChild(activeRing);
            }
        });

        // Device orientation handling with smooth updates
        function handleDeviceOrientation(event) {
            const previousHeading = deviceCompassHeading;
            deviceCompassHeading = event.webkitCompassHeading || Math.abs(event.alpha - 360);

            // Smooth compass transitions
            if (previousHeading !== null) {
                const headingDiff = ((deviceCompassHeading - previousHeading + 180) % 360) - 180;
                deviceCompassHeading = previousHeading + headingDiff * 0.3;
            }

            if (isNavigating) {
                updateNavigation();
            }
        }

        // Direction panel updates
        function updateDirectionPanel(nextPoint) {
            const bearing = calculateBearing(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );

            const distance = calculateDistance(
                userLocation,
                [nextPoint.lat, nextPoint.lng]
            );

            const panel = document.getElementById('direction-panel');
            panel.innerHTML = `
                <span style="font-size: 1.2em;">🎯</span> 
                ${Math.round(bearing)}° 
                <span style="margin: 0 5px;">|</span> 
                ${Math.round(distance)}m
            `;

            // Update color based on distance
            if (distance < 20) {
                panel.style.backgroundColor = 'rgba(76, 175, 80, 0.9)'; // Green
            } else if (distance < 50) {
                panel.style.backgroundColor = 'rgba(255, 152, 0, 0.9)'; // Orange
            } else {
                panel.style.backgroundColor = 'rgba(0, 0, 0, 0.8)'; // Default black
            }
        }

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
            }
            window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
        });

        // Error handling
        window.addEventListener('error', function(event) {
            console.error('Global error:', event.error);
            updateStatusIndicator('Error: ' + event.error.message);
        });
    </script>
</body>
</html>
