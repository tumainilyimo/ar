<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Navigation</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        .arjs-loader {
            position: fixed;
            z-index: 999;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
        }

        .camera-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60%;
            z-index: 1;
        }

        .map-view {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            z-index: 2;
        }

        #map { 
            width: 100%;
            height: 100%;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            display: flex;
            gap: 10px;
            background: rgba(255,255,255,0.9);
            padding: 10px;
            border-radius: 8px;
        }

        input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 140px;
        }

        button {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .direction-indicator {
            position: fixed;
            bottom: 42%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            z-index: 3;
            font-family: Arial, sans-serif;
        }

        a-scene {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="camera-view">
        <a-scene 
            embedded
            vr-mode-ui="enabled: false"
            arjs='sourceType: webcam; videoTexture: true; debugUIEnabled: false; detectionMode: mono;'
        >
            <a-camera gps-camera rotation-reader></a-camera>
            <a-entity id="route-markers"></a-entity>
        </a-scene>
    </div>

    <div class="map-view">
        <div id="map"></div>
    </div>

    <div class="controls">
        <input type="text" id="start" placeholder="Start location">
        <input type="text" id="end" placeholder="End location">
        <button onclick="calculateRoute()">Route</button>
    </div>

    <div id="direction-panel" class="direction-indicator"></div>

    <script>
        let map, userMarker, routingControl;
        let userLocation = null;
        let routePoints = [];
        const ARROW_HEIGHT = 10;
        const ARROW_SCALE = "5 5 5";
        const MIN_DISTANCE = 20;

        window.onload = async () => {
            try {
                const pos = await getCurrentPosition();
                userLocation = [pos.coords.latitude, pos.coords.longitude];
                initMap();
                startLocationTracking();
            } catch (error) {
                console.error('Location error:', error);
                alert('Please enable GPS location');
            }
        };

        function getCurrentPosition() {
            return new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 5000,
                    maximumAge: 0
                });
            });
        }

        function initMap() {
            map = L.map('map').setView(userLocation, 15);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            userMarker = L.marker(userLocation).addTo(map);
        }

        function startLocationTracking() {
            navigator.geolocation.watchPosition(
                pos => {
                    userLocation = [pos.coords.latitude, pos.coords.longitude];
                    userMarker.setLatLng(userLocation);
                    updateNavigation();
                },
                error => console.error('Watch error:', error),
                { enableHighAccuracy: true }
            );
        }

        async function calculateRoute() {
            const start = document.getElementById('start').value;
            const end = document.getElementById('end').value;

            if (!start || !end) {
                alert('Enter both locations');
                return;
            }

            try {
                const startCoords = await geocode(start);
                const endCoords = await geocode(end);

                if (!startCoords || !endCoords) {
                    alert('Location not found');
                    return;
                }

                createRoute(startCoords, endCoords);
            } catch (error) {
                console.error('Route error:', error);
                alert('Route calculation failed');
            }
        }

        async function geocode(location) {
            const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}`
            );
            const data = await response.json();
            return data.length ? [parseFloat(data[0].lat), parseFloat(data[0].lon)] : null;
        }

        function createRoute(start, end) {
            if (routingControl) {
                map.removeControl(routingControl);
            }

            routingControl = L.Routing.control({
                waypoints: [
                    L.latLng(start[0], start[1]),
                    L.latLng(end[0], end[1])
                ],
                routeWhileDragging: false,
                addWaypoints: false,
                createMarker: () => null
            }).addTo(map);

            routingControl.on('routesfound', event => {
                routePoints = event.routes[0].coordinates;
                map.fitBounds(L.latLngBounds(routePoints), { padding: [50, 50] });
                createARDirections();
            });
        }

        function createARDirections() {
            const routeMarkers = document.getElementById('route-markers');
            routeMarkers.innerHTML = '';

            routePoints.forEach((point, index) => {
                if (index % 10 === 0) {
                    const entity = document.createElement('a-entity');
                    entity.setAttribute('gps-entity-place', `latitude: ${point.lat}; longitude: ${point.lng}`);
                    
                    const arrow = document.createElement('a-cone');
                    arrow.setAttribute('color', '#4285f4');
                    arrow.setAttribute('height', ARROW_HEIGHT);
                    arrow.setAttribute('radius-bottom', '2');
                    arrow.setAttribute('position', `0 ${ARROW_HEIGHT/2} 0`);
                    arrow.setAttribute('scale', ARROW_SCALE);

                    const label = document.createElement('a-text');
                    label.setAttribute('value', `${Math.round(index/10 + 1)}`);
                    label.setAttribute('align', 'center');
                    label.setAttribute('position', `0 ${ARROW_HEIGHT + 2} 0`);
                    label.setAttribute('scale', '5 5 5');
                    label.setAttribute('color', 'white');
                    label.setAttribute('look-at', '[gps-camera]');

                    entity.appendChild(arrow);
                    entity.appendChild(label);
                    routeMarkers.appendChild(entity);
                }
            });
        }

        function updateNavigation() {
            if (!routePoints.length || !userLocation) return;

            const nextPoint = findNextPoint();
            if (!nextPoint) return;

            const bearing = calculateBearing(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );

            const distance = calculateDistance(
                userLocation[0], userLocation[1],
                nextPoint.lat, nextPoint.lng
            );

            if (distance < MIN_DISTANCE) {
                routePoints = routePoints.slice(1);
                return;
            }

            document.getElementById('direction-panel').textContent = 
                `${Math.round(bearing)}° - ${Math.round(distance)}m`;
        }

        function findNextPoint() {
            return routePoints.reduce((nearest, point) => {
                const dist = calculateDistance(
                    userLocation[0], userLocation[1],
                    point.lat, point.lng
                );
                return dist < nearest.distance ? {point, distance: dist} : nearest;
            }, {point: null, distance: Infinity}).point;
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const φ1 = lat1 * Math.PI/180;
            const φ2 = lat2 * Math.PI/180;
            const Δφ = (lat2-lat1) * Math.PI/180;
            const Δλ = (lon2-lon1) * Math.PI/180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                     Math.cos(φ1) * Math.cos(φ2) *
                     Math.sin(Δλ/2) * Math.sin(Δλ/2);
            
            return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function calculateBearing(lat1, lon1, lat2, lon2) {
            const φ1 = lat1 * Math.PI/180;
            const φ2 = lat2 * Math.PI/180;
            const Δλ = (lon2-lon1) * Math.PI/180;

            const y = Math.sin(Δλ) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) -
                     Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

            return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
        }
    </script>
</body>
</html>
