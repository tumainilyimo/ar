<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AR Navigation</title>

  <!-- External Libraries -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>
  <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>

  <style>
    body { 
      margin: 0; 
      padding: 0; 
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    /* Split screen layout */
    .container {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* AR Camera View */
    .ar-container {
      flex: 3;
      position: relative;
      background: #000;
    }

    /* Map and Instructions View */
    .map-container {
      flex: 2;
      position: relative;
      display: flex;
    }

    #map {
      flex: 1;
      z-index: 1;
    }

    .instructions {
      position: absolute;
      right: 0;
      top: 0;
      width: 300px;
      max-height: 100%;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      font-size: 14px;
      z-index: 2;
    }

    /* Input Controls */
    .controls {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      display: flex;
      gap: 8px;
      background: white;
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }

    .controls input {
      width: 160px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .controls button {
      padding: 8px 16px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    /* AR Navigation Indicator */
    .direction-indicator {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-weight: bold;
      z-index: 1000;
    }

    /* Make sure A-Frame scene fills AR container */
    a-scene {
      width: 100%;
      height: 100%;
      position: absolute;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- AR View -->
    <div class="ar-container">
      <a-scene embedded vr-mode-ui="enabled: false" 
               arjs="sourceType: webcam; debugUIEnabled: false; trackingMethod: best;">
        <a-camera gps-camera rotation-reader look-controls-enabled="false"></a-camera>
        <a-entity id="routeMarkersContainer"></a-entity>
      </a-scene>

      <div id="directionIndicator" class="direction-indicator"></div>

      <div class="controls">
        <input type="text" id="startLocation" placeholder="Start location"/>
        <input type="text" id="endLocation" placeholder="End location"/>
        <button id="routeBtn">Route</button>
      </div>
    </div>

    <!-- Map View -->
    <div class="map-container">
      <div id="map"></div>
      <div id="instructions" class="instructions"></div>
    </div>
  </div>

  <script>
    let map, userLocationMarker, routeControl;
    let routeCoords = [];
    let userLocation = null;

    window.addEventListener('load', async () => {
      try {
        const position = await getPosition();
        userLocation = [position.coords.latitude, position.coords.longitude];
      } catch (err) {
        console.error('Geolocation error:', err);
        alert('Unable to get your location. Please enable GPS.');
        userLocation = [-3.3667, 36.6833]; // Arusha default
      }

      initMap();
      document.getElementById('routeBtn').addEventListener('click', handleRoute);
    });

    function getPosition() {
      return new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, {
          enableHighAccuracy: true,
          timeout: 30000,
          maximumAge: 0
        });
      });
    }

    function initMap() {
      map = L.map('map').setView(userLocation, 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
      userLocationMarker = L.marker(userLocation).addTo(map);

      navigator.geolocation.watchPosition(
        (pos) => {
          userLocation = [pos.coords.latitude, pos.coords.longitude];
          userLocationMarker.setLatLng(userLocation);
          updateAROverlay();
        },
        console.error,
        { enableHighAccuracy: true }
      );
    }

    async function handleRoute() {
      const start = document.getElementById('startLocation').value.trim();
      const end = document.getElementById('endLocation').value.trim();
      
      if (!start || !end) {
        alert('Please enter both locations');
        return;
      }

      try {
        const startCoords = await geocode(start);
        const endCoords = await geocode(end);
        
        if (!startCoords || !endCoords) {
          alert('Location not found');
          return;
        }

        createRoute(startCoords, endCoords);
      } catch (err) {
        console.error('Routing error:', err);
        alert('Error creating route');
      }
    }

    async function geocode(address) {
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`;
      try {
        const response = await fetch(url);
        const data = await response.json();
        if (data && data.length > 0) {
          return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
        }
      } catch (err) {
        console.error('Geocoding error:', err);
      }
      return null;
    }

    function createRoute(start, end) {
      if (routeControl) {
        map.removeControl(routeControl);
      }

      routeControl = L.Routing.control({
        waypoints: [
          L.latLng(start[0], start[1]),
          L.latLng(end[0], end[1])
        ],
        routeWhileDragging: false,
        addWaypoints: false,
        createMarker: () => null,
        lineOptions: {
          styles: [{color: '#2196F3', weight: 6}]
        }
      })
      .on('routesfound', (e) => {
        const route = e.routes[0];
        routeCoords = route.coordinates;
        
        // Update instructions
        const instructions = route.instructions.map(instruction => 
          `<div style="margin-bottom: 8px;">
            ${instruction.text} - ${instruction.distance}m
           </div>`
        ).join('');
        document.getElementById('instructions').innerHTML = instructions;
        
        // Fit map to show route
        const bounds = L.latLngBounds(route.coordinates);
        map.fitBounds(bounds, {padding: [50, 50]});
        
        createAROverlay();
      })
      .addTo(map);
    }

    function createAROverlay() {
      const container = document.getElementById('routeMarkersContainer');
      container.innerHTML = '';

      routeCoords.forEach((coord, i) => {
        if (i % 3 !== 0) return; // Place marker every 3rd point

        const entity = document.createElement('a-entity');
        entity.setAttribute('gps-entity-place', 
          `latitude: ${coord.lat}; longitude: ${coord.lng}`
        );
        
        const arrow = document.createElement('a-cone');
        arrow.setAttribute('color', '#2196F3');
        arrow.setAttribute('height', '2');
        arrow.setAttribute('radius-bottom', '0.5');
        arrow.setAttribute('position', '0 2 0');
        
        const label = document.createElement('a-text');
        label.setAttribute('value', `${(i/3 + 1)}`);
        label.setAttribute('align', 'center');
        label.setAttribute('position', '0 3 0');
        label.setAttribute('scale', '2 2 2');
        label.setAttribute('color', 'white');
        
        entity.appendChild(arrow);
        entity.appendChild(label);
        container.appendChild(entity);
      });
    }

    function updateAROverlay() {
      if (!routeCoords.length) return;
      
      const nextWaypoint = findNextWaypoint();
      if (!nextWaypoint) return;
      
      const bearing = calculateBearing(
        userLocation[0], userLocation[1],
        nextWaypoint.lat, nextWaypoint.lng
      );
      
      const distance = calculateDistance(
        userLocation[0], userLocation[1],
        nextWaypoint.lat, nextWaypoint.lng
      );
      
      updateDirectionIndicator(bearing, distance);
    }

    function findNextWaypoint() {
      return routeCoords.reduce((nearest, coord) => {
        const dist = calculateDistance(
          userLocation[0], userLocation[1],
          coord.lat, coord.lng
        );
        return dist < nearest.distance ? {coord, distance: dist} : nearest;
      }, {coord: null, distance: Infinity}).coord;
    }

    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const φ1 = lat1 * Math.PI/180;
      const φ2 = lat2 * Math.PI/180;
      const Δφ = (lat2-lat1) * Math.PI/180;
      const Δλ = (lon2-lon1) * Math.PI/180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function calculateBearing(lat1, lon1, lat2, lon2) {
      const φ1 = lat1 * Math.PI/180;
      const φ2 = lat2 * Math.PI/180;
      const λ1 = lon1 * Math.PI/180;
      const λ2 = lon2 * Math.PI/180;

      const y = Math.sin(λ2-λ1) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) -
                Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2-λ1);

      return (Math.atan2(y, x) * 180/Math.PI + 360) % 360;
    }

    function updateDirectionIndicator(bearing, distance) {
      const indicator = document.getElementById('directionIndicator');
      const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const index = Math.round(bearing / 45) % 8;
      
      indicator.textContent = 
        `${Math.round(bearing)}° ${directions[index]} - ${Math.round(distance)}m`;
    }
  </script>
</body>
</html>
